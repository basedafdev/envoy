import * as _shared_core from './clients/core';
import { ClientParams as ClientParams$1, WithIdempotencyKey, Pagination, FeeConfiguration } from './clients/core';
import * as _shared_clients_user_controlled_wallets from './clients/user-controlled-wallets';
import { GenerateUserTokenResponse, Blockchain as Blockchain$1, MetadataField, AccountType, ListUserChallengesStatusEnum, ListUsersPinStatusEnum, ListUsersSecurityQuestionStatusEnum, FeeLevel, ListTransactionsOperationEnum, ListTransactionsStateEnum, ListTransactionsTxTypeEnum, GetTransactionTxTypeEnum } from './clients/user-controlled-wallets';
import { Blockchain } from './clients/configurations';

/**
 * Represents input parameters for identifying a user using a JWT token.
 */
interface UserTokenInput {
    /**
     * The JSON Web Token (JWT) representing the user.
     */
    userToken: string;
    userId?: never;
}
/**
 * Represents input parameters for identifying a user using their system-generated unique identifier.
 */
interface UserIdInput {
    userToken?: never;
    /**
     * Unique system-generated identifier for the user.
     */
    userId: string;
}
interface TokenIdInput {
    /**
     * System generated identifier of the token. Excluded with `tokenAddress` and `tokenBlockchain`.
     */
    tokenId: string;
    tokenAddress?: never;
    blockchain?: never;
}
interface TokenAddressAndBlockchainInput {
    tokenId?: never;
    /**
     * Blockchain address of the transferred token. Empty for native tokens. Excluded with `tokenId`.
     */
    tokenAddress: string;
    /**
     * Blockchain of the transferred token. Required if tokenId is not provided. Excluded with `tokenId`.
     */
    blockchain?: Blockchain;
}
/**
 * Represents input parameters that can be either UserTokenInput or UserIdInput.
 */
type UserIdOrTokenInput = UserIdInput | UserTokenInput;
/**
 * Represents input parameters that can be either UserTokenInput or UserIdInput.
 */
type TokenInfo = TokenIdInput | TokenAddressAndBlockchainInput;
/**
 * Represents a user token that is cached along with its expiration time.
 */
type CachedUserToken = GenerateUserTokenResponse & {
    /**
     * The expiration time in seconds for the cached user token.
     */
    expirationTime: number;
};
type ClientParams = ClientParams$1<Record<string, CachedUserToken>>;

/**
 * Represents the input for creating a challenge for PIN setup and create wallet(s).
 */
type CreateUserPinWithWalletsInput = {
    /**
     * Blockchain(s) the requested wallets will be created on.
     */
    blockchains: Blockchain$1[];
    /**
     * List of metadata fields to associate with the corresponding wallet.
     */
    metadata?: MetadataField[];
    /**
     * An account can be categorized as a Smart Contract Account (SCA) or an Externally Owned Account (EOA). For detailed information about these account types and their distinctions, please refer to the account types guide.
     *
     * By default, if an account type is not specified when creating a wallet, it will be classified as an Externally Owned Account (EOA).
     */
    accountType?: AccountType;
} & UserIdOrTokenInput & WithIdempotencyKey;

/**
 * Represents input parameters for managing a user's PIN.
 */
type ManageUserPinInput = UserIdOrTokenInput & WithIdempotencyKey;

/**
 * Represents the input parameters for fetching a user's challenges.
 */
type ListUserChallengesInput = {
    /**
     * The JSON Web Token (JWT) representing the user.
     */
    userToken: string;
    /**
     * The status of challenges to query. (Optional).
     */
    challengeStatus?: ListUserChallengesStatusEnum;
};

/**
 * Represents the input parameters for fetching a challenge.
 */
type GetUserChallengeInput = {
    /**
     * The unique identifier for the challenge.
     */
    challengeId: string;
    /**
     * The JSON Web Token (JWT) representing the user.
     */
    userToken: string;
};

/**
 * Represents the input parameters for creating a user token.
 */
type CreateUserTokenInput = {
    /**
     * The unique identifier generated by your system for the user.
     */
    userId: string;
};

/**
 * Represents the input parameters for listing users.
 */
type ListUsersInput = {
    /**
     * The pin status to filter users. (Optional).
     */
    pinStatus?: ListUsersPinStatusEnum;
    /**
     * The security question status to filter users. (Optional).
     */
    securityQuestionStatus?: ListUsersSecurityQuestionStatusEnum;
} & Pagination;

/**
 * Represents the input parameters for fetching a user by user token.
 */
type GetUserByTokenInput = {
    /**
     * The JSON Web Token (JWT) representing the user.
     */
    userToken: string;
};

/**
 * Represents the input parameters for fetching a user.
 */
type GetUserInput = {
    /**
     * The unique identifier generated by your system for the user.
     */
    userId: string;
};

/**
 * Represents the input parameters for creating a user.
 */
type CreateUserInput = {
    /**
     * The unique identifier generated by your system for the user.
     */
    userId: string;
};

/**
 * Represents the input parameters for retrieving the NFT balance of a wallet.
 */
type GetWalletNFTBalanceInput = {
    /**
     * The ID of the wallet to retrieve the NFTs for.
     */
    walletId: string;
    /**
     * Specifies whether to include all tokens.
     */
    includeAll?: boolean;
    /**
     * The name of the token to filter for.
     */
    name?: string;
    /**
     * An array of token addresses.
     */
    tokenAddresses?: string[];
    /**
     * Token standard.
     */
    standard?: 'ERC20' | 'ERC721' | 'ERC1155';
} & UserIdOrTokenInput & Omit<Pagination, 'from' | 'to'>;

/**
 * Represents the input parameters for retrieving the token balance of a wallet.
 */
type GetWalletTokenBalanceInput = {
    /**
     * The ID of the wallet to retrieve the tokens for.
     */
    walletId: string;
    /**
     * Specifies whether to include all tokens.
     */
    includeAll?: boolean;
    /**
     * The name of the token to filter for.
     */
    name?: string;
    /**
     * An array of token addresses.
     */
    tokenAddresses?: string[];
    /**
     * Token standard.
     */
    standard?: 'ERC20' | 'ERC721' | 'ERC1155';
} & UserIdOrTokenInput & Omit<Pagination, 'from' | 'to'>;

/**
 * Represents the input parameters for updating a wallet.
 */
type UpdateWalletInput = {
    /**
     * The ID of the wallet to be updated.
     */
    id: string;
    /**
     * The new name for the wallet.
     */
    name?: string;
    /**
     * The new refId for the wallet.
     */
    refId?: string;
} & UserIdOrTokenInput;

/**
 * Represents the input parameters for retrieving a wallet.
 */
type GetWalletInput = {
    /**
     * The ID of the wallet to retrieve.
     */
    id: string;
} & UserIdOrTokenInput;

/**
 * Represents the input for listing wallets.
 */
type ListWalletsFilterInput = {
    /**
     * The address of the wallet to filter by.
     */
    address?: string;
    /**
     * The blockchain to filter by.
     */
    blockchain?: Blockchain$1;
    /**
     * The ID of the wallet set to filter by.
     */
    walletSetId?: string;
    /**
     * Reference or description used to identify the wallet.
     */
    refId?: string;
} & UserIdOrTokenInput & Pagination;

/**
 * Represents the input parameters for creating multiple wallets.
 */
type CreateWalletsInput = {
    /**
     * The blockchains for which to create wallets.
     */
    blockchains: Blockchain$1[];
    /**
     * Optional list of metadata fields to associate with the corresponding wallet.
     * If count is specified, the amount of items in the array should match the count field.
     */
    metadata?: MetadataField[];
    /**
     * An account can be categorized as a Smart Contract Account (SCA) or an Externally Owned Account (EOA). For detailed information about these account types and their distinctions, please refer to the account types guide.
     *
     * By default, if an account type is not specified when creating a wallet, it will be classified as an Externally Owned Account (EOA).
     */
    accountType?: AccountType;
} & UserIdOrTokenInput & WithIdempotencyKey;

/**
 * Represents the input parameters for validating an address.
 */
interface ValidateAddressInput {
    /**
     * The blockchain address to be validated.
     */
    address: string;
    /**
     * The blockchain that the address should belong to.
     */
    blockchain: Blockchain$1;
}

/**
 * Represents the input parameters for estimating transfer fees.
 */
type EstimateTransferFeeInput = {
    /**
     * Specifies the transfer amount in decimal format.
     */
    amount: string[];
    /**
     * The recipient's blockchain address.
     */
    destinationAddress: string;
    /**
     * The source blockchain address of the transaction.
     */
    sourceAddress?: string;
    /**
     * Identifier for the originating wallet.
     */
    walletId?: string;
    /**
     * The list of NFT IDs to be transferred/batchTransferred for NFT withdrawal.
     * Note: Only ERC-1155 tokens support safeBatchTransferFrom.
     */
    nftTokenIds?: string[];
} & UserIdOrTokenInput & TokenInfo;

/**
 * Represents the input parameters for creating a new contract execution transaction.
 */
type CreateContractExecutionTransactionInput = {
    /**
     * The contract ABI function signature or `callData` field is required for interacting with the smart contract. The ABI function signature cannot be used simultaneously with `callData`. e.g. Burn(uint256).
     */
    abiFunctionSignature?: string;
    /**
     * The contract ABI function signature parameters for executing the contract interaction. Supported parameter types include string, integer, boolean, and array. These parameters should be used exclusively with the abiFunctionSignature and cannot be used with `callData`.
     */
    abiParameters?: Array<any>;
    /**
     * The raw transaction data, must be an even-length hexadecimal string with the `0x` prefix, to be executed. It is important to note that the usage of `callData` is mutually exclusive with the `abiFunctionSignature` and `abiParameters`. Therefore, `callData` cannot be utilized simultaneously with either `abiFunctionSignature` or `abiParameters`.
     */
    callData?: string;
    /**
     * The amount of native token that will be sent to the contract abi execution. Optional field for payable api only, if not provided, no native token will be sent.
     */
    amount?: string;
    /**
     * The blockchain address of the contract to be executed.
     */
    contractAddress: string;
    /**
     * Optional reference or description used to identify the transaction.
     */
    refId?: string;
    /**
     * Unique system generated identifier of the wallet. Required when source Address and blockchain is not provided. Mutually exclusive. For contract deploys this wallet ID will be used as the source.
     */
    walletId: string;
    /**
     * Configuration that determines the fees that will be paid.
     */
    fee: FeeConfiguration<FeeLevel>;
} & UserIdOrTokenInput & WithIdempotencyKey;

/**
 * Represents the input parameters for estimating transfer fees.
 */
type EstimateContractExecutionFeeInput = {
    /**
     * The contract ABI function signature to be interacted with in the smart contract. For example, `burn(uint256)`.
     */
    abiFunctionSignature: string;
    /**
     * The parameters required by the contract ABI function to perform the contract interaction.
     */
    abiParameters: Array<any>;
    /**
     * The blockchain address of the contract to be executed.
     */
    contractAddress: string;
    /**
     * Information about the source.
     */
    source: {
        /**
         * Identifier for the originating wallet.
         */
        walletId: string;
    } | {
        /**
         * Blockchain associated with the transaction. Required along with sourceAddress.
         */
        blockchain: Blockchain$1;
        /**
         * The source blockchain address of the transaction.
         */
        sourceAddress: string;
    };
} & UserIdOrTokenInput;

/**
 * Defines the parameters for querying a list of transactions.
 */
type ListTransactionsInput = {
    /**
     * Filters transactions based on the blockchain they occur on.
     */
    blockchain?: Blockchain$1;
    /**
     * Filters transactions based on their destination address.
     */
    destinationAddress?: string;
    /**
     * Determines whether the query should include all tokens.
     * If set to true, results will include all tokens.
     */
    includeAll?: boolean;
    /**
     * Filters transactions based on their operation.
     */
    operation?: ListTransactionsOperationEnum;
    /**
     * Filters transactions based on their current state.
     */
    state?: ListTransactionsStateEnum;
    /**
     * Filters for a specific transaction hash.
     */
    txHash?: string;
    /**
     * Filters transactions based on their type.
     */
    txType?: ListTransactionsTxTypeEnum;
    /**
     * Filters transactions based on the owning wallets.
     * Input should be an array of walletIds.
     */
    walletIds?: string[];
} & UserIdOrTokenInput & Pagination;

/**
 * Represents the input for retrieving a transaction.
 */
type GetTransactionInput = {
    /**
     * The ID of the transaction to retrieve.
     */
    id: string;
    /**
     * Filters on the transaction type of the transaction.
     */
    txType?: GetTransactionTxTypeEnum;
} & UserIdOrTokenInput;

/**
 * Represents the input for cancelling a transaction.
 */
type CancelTransactionInput = {
    /**
     * The ID of the transaction that should be cancelled.
     */
    id: string;
} & UserIdOrTokenInput & WithIdempotencyKey;

/**
 * Defines the parameters for creating a new transaction.
 */
type CreateTransactionInput = {
    /**
     * Specifies the transfer amount in decimal format.
     */
    amounts: string[];
    /**
     * The recipient's blockchain address.
     */
    destinationAddress: string;
    /**
     * Identifier for the originating wallet.
     */
    walletId: string;
    /**
     * The list of NFT IDs to be transferred/batchTransferred for NFT withdrawal.
     * Note: Only erc1155 supports safeBatchTransferFrom.
     */
    nftTokenIds?: string[];
    /**
     * An optional client-provided reference or description for the transaction.
     */
    refId?: string;
    /**
     * Configuration to determine the fees that will be paid.
     */
    fee: FeeConfiguration<FeeLevel>;
} & UserIdOrTokenInput & TokenInfo & WithIdempotencyKey;

/**
 * Represents the input for accelerating a transaction.
 */
type AccelerateTransactionInput = {
    /**
     * The ID of the transaction that should be accelerated.
     */
    id: string;
} & UserIdOrTokenInput & WithIdempotencyKey;

/**
 * Represents the input to sign the EIP-712 typed structured data from a specified user-controlled wallet.
 */
type SignTypedDataInput = {
    /**
     * Unique system generated identifier of the wallet.
     */
    walletId: string;
    /**
     * A string represents the typed structured data in EIP-712.
     */
    data: string;
    /**
     * The human readable explanation for this sign action. Useful for presenting with extra information.
     */
    memo?: string;
} & UserIdOrTokenInput;

/**
 * Represents the input to sign the EIP-191 message from a specified user-controlled wallet.
 */
type SignMessageInput = {
    /**
     * Unique system generated identifier of the wallet.
     */
    walletId: string;
    /**
     * Indicator of whether the input message is encoded by hex. If TRUE, then the message should be a hex string. By default, it is False.
     */
    encodedByHex?: boolean;
    /**
     * The user friendly message that needs to be signed.
     * If it is a hex string, encodedByHex needs to be TRUE. The hex string should start with “0x” and have even length.
     */
    message: string;
    /**
     * The human readable explanation for this sign action. Useful for presenting with extra information.
     */
    memo?: string;
} & UserIdOrTokenInput;

/**
 * Represents the input parameters for retrieving a token.
 */
interface GetTokenInput {
    /**
     * The ID of the token to retrieve.
     */
    id: string;
}

declare const defaultBaseUrl = "https://api.circle.com";
/**
 * Initiates a client for Circle's User Controlled Wallets.
 * @param params - The client parameters.
 * @returns - The client object with various methods.
 */
declare function initiateUserControlledWalletsClient({ apiKey, baseUrl, storage, userAgent, headers, }: ClientParams): {
    /**
     * Fetches details of a specific token given its unique identifier.
     * Every token in your network of wallets has a UUID associated with it,
     * regardless of whether it's already recognized or was added as a monitored token.
     * @example
     * ```
     * const response = await client.getToken(id);
     * console.log(response.data.token)
     * ```
     */
    getToken: ({ id }: GetTokenInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.GetTokenId200Response>>;
    /**
     * Generates a challenge for signing the EIP-191 message from a specified user-controlled wallet.
     * Please note that not all the Dapps currently support Smart Contract Account (SCA),
     * the difference between EOA and SCA can be found in the account types guide, and you can check the list of Dapps that support SCA: https://eip1271.io/.
     * @example
     * ```
     * const response = await client.signMessage({
     *  userToken: 'dummy-user-token',
     *  walletId: 'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11',
     *  encodedByHex: false,
     *  message: 'I agree with this transfer',
     *  memo: 'Transfer USDC to Sam',
     * })
     * console.log(response.data?.signature)
     * ```
     */
    signMessage: ({ userToken, userId, ...input }: SignMessageInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.SignUserMessage200Response>>;
    /**
     * Generates a challenge for signing the EIP-712 typed structured data from a specified user-controlled wallet.
     * Please note that not all the Dapps currently support Smart Contract Account (SCA),
     * the difference between EOA and SCA can be found in the account types guide, and you can check the list of Dapps that support SCA: https://eip1271.io/.
     * @example
     * ```
     * const response = await client.signTypedData({
     *  userToken: 'dummy-user-token',
     *  walletId: 'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11',
     *  data: '{ \"types\": { \"Data\": [{ \"name\": \"dummy\", \"type\": \"string\" }],}, \"domain\": { \"name\": \"Test\", \"chainId\": 1337 }, \"primaryType\": \"Data\", \"message\": { \"dummy\": \"dummy\" }}',
     *  memo: 'Transfer USDC to Sam',
     * })
     * console.log(response.data?.signature)
     * ```
     */
    signTypedData: ({ userToken, userId, ...input }: SignTypedDataInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.SignUserTypedData200Response>>;
    /**
     * Generates a challenge for accelerating a specified on-chain digital asset transfer from a user-controlled wallet.
     *
     * Additional gas fees may be incurred.
     * @example
     * ```
     * const response = await client.accelerateTransaction({
     *  userToken: 'dummy-user-token',
     *  id: '50dcf3c7-bcc0-465d-bb72-7b84f82a4887',
     * })
     * console.log(response.data?.challengeId)
     * ```
     */
    accelerateTransaction: ({ userToken, userId, id, idempotencyKey, }: AccelerateTransactionInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.CreateUserTransactionAccelerateChallenge200Response>>;
    /**
     * Generates a challenge for initiating an on-chain digital asset transfer from a specified user-controlled wallet.
     * @example
     * ```
     * const response = await client.createTransaction({
     *  userToken: 'dummy-user-token',
     *  amount: ['0.01'],
     *  destinationAddress: '0xa51c9c604b79a0fadbfed35dd576ca1bce71da0a',
     *  tokenId: '738c8a6d-8896-46d1-b2cb-083600c1c69b',
     *  walletId: 'a635d679-4207-4e37-b12e-766afb9b3892',
     *  fee: {
     *    type: 'level',
     *    config: {
     *      feeLevel: 'HIGH',
     *    },
     *  },
     * })
     * console.log(response.data?.challengeId)
     * ```
     */
    createTransaction: ({ userToken, userId, idempotencyKey, fee, ...input }: CreateTransactionInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.CreateUserTransactionTransferChallenge200Response>>;
    /**
     * Generates a challenge for cancelling a specified on-chain digital asset transfer from a user-controlled wallet.
     *
     * Gas fees may still be incurred.
     * @example
     * ```
     * const response = await client.cancelTransaction({
     *  userToken: 'dummy-user-token',
     *  id: '50dcf3c7-bcc0-465d-bb72-7b84f82a4887',
     * })
     * console.log(response.data?.challengeId)
     * ```
     */
    cancelTransaction: ({ userToken, userId, id, idempotencyKey, }: CancelTransactionInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.CreateUserTransactionCancelChallenge200Response>>;
    /**
     * Retrieves info for a single transaction using it's unique identifier.
     * @example
     * ```
     * const response = await client.getTransaction({
     *  userToken: 'dummy-user-token',
     *  id: '50dcf3c7-bcc0-465d-bb72-7b84f82a4887',
     * })
     * console.log(response.data)
     * ```
     */
    getTransaction: ({ id, userToken, userId, txType }: GetTransactionInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.GetTransaction200Response>>;
    /**
     * Lists all transactions. Includes details such as status, source/destination, and transaction hash.
     * @example
     * ```
     * const response = await client.listTransactions({
     *  userToken: 'dummy-user-token',
     * });
     * console.log(response.data)
     * ```
     */
    listTransactions: ({ userToken, blockchain, destinationAddress, includeAll, operation, state, txHash, txType, userId, walletIds, from, pageAfter, pageBefore, pageSize, to, }: ListTransactionsInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.ListTransactions200Response>>;
    /**
     * Estimates gas fees that will be incurred for a contract execution transaction, given its ABI parameters and blockchain.
     * @example
     * ```
     * const response = await client.estimateContractExecutionFee({
     *  abiFunctionSignature: 'burn(uin256)',
     *  abiParameters: [1000],
     *  contractAddress: '656d6fd6-d430-459c-9ba4-5c2074433f1b',
     *  source: {
     *    walletId: '9a014a34-4706-4e3f-879d-fc2a8764877c',
     *  },
     * })
     * console.log(response.data)
     * ```
     */
    estimateContractExecutionFee: ({ userId, userToken, source, ...input }: EstimateContractExecutionFeeInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.CreateTransferEstimateFee200Response>>;
    /**
     * Generates a challenge for creating a transaction which executes a smart contract. ABI parameters must be passed in the request.
     * @example
     * ```
     * const response = await client.createUserTransactionContractExecutionChallenge({
     *  userToken: 'dummy-user-token',
     *  amount: '0.01',
     *  abiFunctionSignature: 'burn(uint256)',
     *  abiParameters: [
     *    1,
     *  ],
     *  contractAddress: '0xf9f4d0a9dcc57d15d32a9a52c71fdfef91bdf0e4',
     *  refId: 'f26d2545-7ff7-4cac-ba02-40e1975e5dbe',
     *  walletId: 'd67e2f61-2b4f-40ab-9ac5-eee8ff56613c',
     *  fee: {
     *    type: 'level',
     *    config: {
     *      feeLevel: 'HIGH',
     *    },
     *  },
     * })
     * console.log(response.data)
     * ```
     */
    createUserTransactionContractExecutionChallenge: ({ userToken, userId, idempotencyKey, fee, ...input }: CreateContractExecutionTransactionInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.CreateUserTransactionContractExecutionChallenge200Response>>;
    /**
     * Estimates gas fees that will be incurred for a transfer transaction; given its amount, blockchain, and token.
     * @example
     * ```
     * const response = await client.estimateTransferFee({
     *  amount: ['0.01'],
     *  destinationAddress: '656d6fd6-d430-459c-9ba4-5c2074433f1b',
     *  tokenId: '9606f293-5b81-4970-acd3-c35c157461c2',
     * })
     * console.log(response.data)
     * ```
     */
    estimateTransferFee: ({ userToken, userId, amount, ...input }: EstimateTransferFeeInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.CreateTransferEstimateFee200Response>>;
    /**
     * Confirms that a specified address is valid for a certain blockchain.
     * @example
     * ```
     * const response = await client.validateAddress({
     *  address: '0xa95f8fafb3f6ae0f9ba7204eef07bde7a64cf2bc',
     *  blockchain: 'ETH-SEPOLIA',
     * })
     * console.log(response.data?.isValid)
     * ```
     */
    validateAddress: (input: ValidateAddressInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.CreateValidateAddress200Response>>;
    /**
     * Generates a challenge for creating a new user-controlled wallet or batch of wallets, specifying blockchain and wallet name.
     * @example
     * ```
     * const response = await userClient.createWallet({
     *  userToken: 'dummy-user-token',
     *  blockchains: [Blockchain.Eth, Blockchain.Matic],
     * })
     * console.log(response.data?.challengeId)
     * ```
     */
    createWallet: ({ userToken, userId, idempotencyKey, accountType, ...input }: CreateWalletsInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.CreateUserWallet200Response>>;
    /**
     * Retrieves a list of all user-controlled wallets that fit the specified parameters.
     * @example
     * ```
     * const response = await userClient.listWallets({
     *  userToken: 'dummy-user-token',
     * })
     * console.log(response.data?.wallets)
     * ```
     */
    listWallets: ({ userId, userToken, address, blockchain, from, pageAfter, pageBefore, pageSize, to, walletSetId, refId, }: ListWalletsFilterInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.ListWallets200Response>>;
    /**
     * Retrieves info for a single user-controlled wallet using it's unique identifier.
     * @example
     * ```
     * const response = await userClient.getWallet({
     *  id: 'dummy-wallet-id',
     *  userToken: 'dummy-user-token',
     * })
     * console.log(response.data?.wallet)
     * ```
     */
    getWallet: ({ id, userToken, userId }: GetWalletInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.GetWallet200Response>>;
    /**
     * Updates info for a single user-controlled wallet using it's unique identifier.
     * @example
     * ```
     * const response = await userClient.updateWallet({
     *  id: 'dummy-wallet-id',
     *  userToken: 'dummy-user-token',
     * })
     * console.log(response.data?.wallet)
     * ```
     */
    updateWallet: ({ id, name, refId, userToken, userId }: UpdateWalletInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.UpdateWallet200Response>>;
    /**
     * Fetches the digital asset balance for a single user-controlled wallet using its unique identifier.
     * @example
     * ```
     * const response = await userClient.getWalletTokenBalance({
     *  id: 'dummy-wallet-id',
     *  userToken: 'dummy-user-token',
     * })
     * console.log(response.data?.tokenBalances)
     * ```
     */
    getWalletTokenBalance: ({ walletId, userToken, userId, includeAll, name, pageAfter, pageBefore, pageSize, tokenAddresses, standard, }: GetWalletTokenBalanceInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.ListWalletBallance200Response>>;
    /**
     * Fetches the info for all NFTs stored in a single user-controlled wallet, using the wallets unique identifier.
     * @example
     * ```
     * const response = await userClient.getWalletNFTBalance({
     *  id: 'dummy-wallet-id',
     *  userToken: 'dummy-user-token',
     * })
     * console.log(response.data?.nfts)
     * ```
     */
    getWalletNFTBalance: ({ walletId, userToken, userId, includeAll, name, pageAfter, pageBefore, pageSize, tokenAddresses, standard, }: GetWalletNFTBalanceInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.ListWalletNfts200Response>>;
    /**
     * Create a user.
     * @example
     * ```
     * const response = client.createUser({
     *   userId: '67eb6eac-a7f5-4c04-9200-2fbf969426b0',
     * })
     * console.log(response.status)
     * ```
     */
    createUser: ({ ...input }: CreateUserInput) => Promise<_shared_core.TrimDataResponse<object>>;
    /**
     * Get user by ID.
     * @example
     * ```
     * const response = client.getUser({
     *   userId: '67eb6eac-a7f5-4c04-9200-2fbf969426b0',
     * })
     * console.log(response.data?.user?.pinStatus)
     * ```
     */
    getUser: ({ userId }: GetUserInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.GetUser200Response>>;
    /**
     * Get user's PIN and Security Question statuses.
     * @example
     * ```
     * const response = await userClient.getUserStatus({
     *   userToken: 'dummy-user-token',
     * })
     *  console.log(response.data?.pinDetails)
     * ```
     */
    getUserStatus: ({ userToken }: GetUserByTokenInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.GetUserByToken200Response>>;
    /**
     * Get all the users under the entity, sorted by the create date DESC order.
     * @example
     * ```
     * const response = await userClient.listUsers()
     * console.log(response.data?.users?.at(0)?.pinStatus)
     * ```
     */
    listUsers: ({ pinStatus, securityQuestionStatus, from, to, pageBefore, pageAfter, pageSize, }?: ListUsersInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.ListUsers200Response>>;
    /**
     * Generate user session and SDK secret key.
     * @example
     * ```
     * const response = await userClient.createUserToken({
     *  userId: '67eb6eac-a7f5-4c04-9200-2fbf969426b0',
     * })
     * console.log(response.data?.userToken, response.data?.encryptionKey)
     * ```
     */
    createUserToken: ({ ...input }: CreateUserTokenInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.GetUserToken200Response>>;
    /**
     * Get the status of a challenge.
     * @example
     * ```
     * const response = await userClient.getUserChallenge({
     *  userToken: 'dummy-user-token',
     *  challengeId: '0db6141b-1091-4e39-a20b-6a4cde68e1e7',
     * })
     * console.log(response.data?.challenge?.status)
     * ```
     */
    getUserChallenge: ({ userToken, challengeId }: GetUserChallengeInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.GetUserChallenge200Response>>;
    /**
     * List all challenges by status for a user.
     * @example
     * ```
     * const response = await userClient.listUserChallenges({
     *  userToken: 'dummy-user-token',
     * })
     * console.log(response.data?.challenges?.at(0)?.status)
     * ```
     */
    listUserChallenges: ({ userToken, challengeStatus }: ListUserChallengesInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.ListUserChallenges200Response>>;
    /**
     * Create a challenge for PIN setup without setting up wallets.
     * @example
     * ```
     * const response = await userClient.createUserPin({
     *  userId: '67eb6eac-a7f5-4c04-9200-2fbf969426b0',
     * })
     * console.log(response.data?.challengeId)
     * ```
     */
    createUserPin: ({ userToken, userId, idempotencyKey }: ManageUserPinInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.CreateUserWithPinChallenge200Response>>;
    /**
     * Create a challenge for PIN setup and create wallet(s).
     * @example
     * ```
     * const response = await userClient.createUserPinWithWallets({
     *  userToken: 'dummy-user-token',
     *  blockchains: [Blockchain.Eth, Blockchain.Matic],
     * })
     * console.log(response.data?.challengeId)
     * ```
     */
    createUserPinWithWallets: ({ userToken, userId, idempotencyKey, accountType, ...input }: CreateUserPinWithWalletsInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.CreateUserWithPinChallenge200Response>>;
    /**
     * Create a challenge to update a user's PIN via existing PIN.
     * @example
     * ```
     * const response = await userClient.updateUserPin({
     *  userToken: 'dummy-user-token',
     * })
     * console.log(response.data?.challengeId)
     * ```
     */
    updateUserPin: ({ userToken, userId, idempotencyKey }: ManageUserPinInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.UpdateUserPinChallenge200Response>>;
    /**
     * Create a challenge to change a user's PIN via Security Questions.
     * @example
     * ```
     * const response = await userClient.restoreUserPin({
     *  userToken: 'dummy-user-token',
     * })
     * console.log(response.data?.challengeId)
     * ```
     */
    restoreUserPin: ({ userToken, userId, idempotencyKey }: ManageUserPinInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.CreateUserPinRestoreChallenge200Response>>;
};

export { defaultBaseUrl, initiateUserControlledWalletsClient };
