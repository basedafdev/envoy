"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Subscriptions = void 0;
const util_internal_1 = require("@subsquid/util-internal");
const assert_1 = __importDefault(require("assert"));
const errors_1 = require("./errors");
class Subscriptions {
    constructor(client) {
        this.client = client;
        this.active = new Map();
        this.client.addNotificationListener(msg => this.onNotification(msg));
        this.client.addResetListener(err => this.onReset(err));
    }
    add(sub) {
        return new Handle(sub, this.client, this.active);
    }
    onNotification(msg) {
        let subscription = msg.params?.subscription;
        switch (typeof subscription) {
            case 'number':
            case 'string':
                break;
            default:
                return;
        }
        let key = `${msg.method}::${subscription}`;
        let handle = this.active.get(key);
        if (handle == null)
            return;
        let params = msg.params;
        if (params.error) {
            let err = new errors_1.RpcError(params.error);
            handle.sub.onError(err);
        }
        else {
            handle.sub.onMessage(params.result);
        }
    }
    onReset(err) {
        for (let handle of this.active.values()) {
            handle.onConnectionReset(err);
        }
    }
}
exports.Subscriptions = Subscriptions;
class Handle {
    constructor(sub, client, active) {
        this.sub = sub;
        this.client = client;
        this.active = active;
        this.closed = false;
        this.subscribe();
    }
    get isActive() {
        return !this.closed;
    }
    get isClosed() {
        return this.closed;
    }
    getSubKey() {
        (0, assert_1.default)(this.id != null);
        return `${this.sub.notification}::${this.id}`;
    }
    close() {
        if (this.closed)
            return;
        this.closed = true;
        this.unsubscribe();
    }
    onConnectionReset(reason) {
        if (this.closed)
            return;
        this.active.delete(this.getSubKey());
        this.id = undefined;
        if (reason instanceof errors_1.RpcConnectionError && this.sub.resubscribeOnConnectionLoss) {
            this.subscribe();
        }
        else {
            this.closed = true;
            this.sub.onError(reason);
        }
    }
    subscribe() {
        this.client.call(this.sub.method, this.sub.params, {
            retryAttempts: this.sub.retryAttempts,
            validateResult: (result, req) => this.validateSubscriptionResult(result, req)
        }).then(id => {
            this.id = id;
            if (this.isActive) {
                this.active.set(this.getSubKey(), this);
            }
            else {
                this.unsubscribe();
            }
        }, err => {
            if (this.closed)
                return;
            if (err instanceof errors_1.RpcConnectionError && this.sub.resubscribeOnConnectionLoss) {
                this.subscribe();
            }
            else {
                this.closed = true;
                this.sub.onError(err);
            }
        });
    }
    unsubscribe() {
        if (this.id == null)
            return;
        this.doUnsubscribe().then();
    }
    doUnsubscribe() {
        this.active.delete(this.getSubKey());
        let id = this.id;
        this.id = undefined;
        return this.client.call(this.sub.unsubscribe, [id], { retryAttempts: 0 }).catch(err => {
            if (err instanceof errors_1.RpcConnectionError)
                return;
            this.client.reset((0, util_internal_1.addErrorContext)(new errors_1.RpcConnectionError('connection was reset due to subscription cancellation error'), { rpcSubscriptionCancellationError: err }));
        });
    }
    reset() {
        if (this.id == null)
            return;
        this.doUnsubscribe().then(() => {
            if (this.closed)
                return;
            this.subscribe();
        });
    }
    validateSubscriptionResult(result, req) {
        switch (typeof result) {
            case 'string':
            case 'number':
                break;
            default:
                this.client.reset();
                throw (0, util_internal_1.addErrorContext)(new Error('unexpected subscription result: ' +
                    'only numbers and strings are accepted as subscription ids'), {
                    rpcResult: result
                });
        }
        let key = `${this.sub.notification}::${result}`;
        if (this.active.has(key)) {
            this.client.reset();
            throw new Error(`got duplicate subscription: ${result}`);
        }
        return result;
    }
}
//# sourceMappingURL=subscriptions.js.map